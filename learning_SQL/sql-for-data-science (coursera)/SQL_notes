SQL: Structured Query Language.
----------------------------------------------------------------------------
SQL is all about data
----------------------------------------------------------------------------
SQL used to query, insert, update and modify data. 
----------------------------------------------------------------------------
SQL is non-procedural language:
  * cannot write completed applicataions.
  * Simple, but powerfull
----------------------------------------------------------------------------
Data Scientist might do a little of the analysis using SQL, however the main thing they're using SQL for is data retrieval. 
----------------------------------------------------------------------------
how you write syntax witt depend on what DBMS(database managment system) you are using, each DBMS its own "dialect", you will tweak based on the "dialect" your DMBS speaks.
----------------------------------------------------------------------------
Miscrosoft SQL Server, IBM DB2 Oracle, Sybase ASE, PostgreSQL, MySQL, Apache Open Office Base, SQLite
----------------------------------------------------------------------------
we use SQLite in this course
----------------------------------------------------------------------------
Database: A container that is used to organize and store all the data.
----------------------------------------------------------------------------
Table: A structured list of data or a specific type (like excel table)
----------------------------------------------------------------------------
Data Modeling: Organizes and structures information into multiple, related tables.
The data model scheme of organization should always represent the real world as closely as possible. 
----------------------------------------------------------------------------
NoSQL: Not Only SQL
A mechanism for storage and retrieval of unstructured data modeled by means other than batular relations in relationnal databases.
----------------------------------------------------------------------------
Relational vs Transactional Model

Relational Model: A database design tha shows the relationships between the different tables, this is really used to optimize querying data, Allows for easy querying and data manipulation in an easy, logical and intuitive way.

Transactional Model: more Operationl database, information may not be stored in a great way for querying and using it for analysis
----------------------------------------------------------------------------
Data Model Building Blocks:
Entity: Person, place, thing, or event
		Distinguishabel, unique, and distinct
Attribute:A characteristic of an entity
Relationship: Describes association among entities:
	1- One-to-many (eg. customer to invoices)
	2- Many-to-many (eg. student to classes)
	3- One-to_one (eg. manager to store)
----------------------------------------------------------------------------
ER model <https://d3c33hcgiwev3.cloudfront.net/JIQNlAqcEei8LQpwydYI3g.processed/full/540p/index.webm?Expires=1541808000&Signature=FePpr~ZG-hWl5-dmrIQ3rxB41Es1BkJ0elECyXrw0501crarca7plbwEwnr~un4vxx7hDZa9RQ5pug23KhMgvDIcIE1OuBLqDotmt0RUZzUsFw82DnI0tOktd-kn6x9G~VP7kjUwyXYtyJyi0xWvsrB37XOXNN0X2CsX0lS0ptc_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A>
dubare repeat karna h, samajh nahi aaya
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Retrieve Data 															Retrieve Data
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
# SELECT for one column
SELECT colum_name 
FROM table;
----------------------------------------------------------------------------
# SELECT for morethan one column
SELECT column_1, column_2, column_3 
FROM table;

or 

SELECT column_1
		, column_2
		, column_3
FROM table;
----------------------------------------------------------------------------
# Select all tables
SELECT *
FROM table;
----------------------------------------------------------------------------
# observations limit (first n records)
SELECT column
FROM table
LIMIT 5;

#in Oracle:
SELECT column
FROM table
WHERE ROWNUM <= 5;

#in DB2:
SELECT column
FROM table
FETCH FIRST 5 ROWS ONLY;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Create Data 															Create Data
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
# create table (not a data, but column names, type of data in each column ... etc)
CREATE TABLE table_name
	(
	Id 		char(10)			PRIMARY KEY,
	Brand 	char(10) 			NOT NULL,
	Type 	char(250)			NOT NULL,
	Color 	char(250)			NOT NULL,
	Price 	decimal(8,2) 		NOT NULL,
	Desc 	Varchar (750)		NULL
	);
# Id, Brand, Type, Color, Price, Desc columns names hen
# <Id> column k andar characher type ka data ay ga, jis ki lenght maximum 10 ho gi, column <Type> me 250 characters allow hen........... 
# phir agli entries <PRIMARY KEY, NOT NULL, NULL> is baat ki hen k in column me null value ijaazat h ya nahi, agar khali chor den gy to by default NULL values allow hon gi 
# Every column is either NULL or NOT NULL, an error will be returned if one tries to submit a column with no value, don't confuse null values with empty strings, epmpty string not a null value, NOTE: Primary keys cannot be null or empty value
Note: NULL represents no value
----------------------------------------------------------------------------
# Adding Data to the Table
# when you are sure about order of columns
INSERT INTO table_name
VALUES('14535974'
	,'Gucci'
	,'slippers'
	,'Pink'
	,695.00
	,NULL
	);
# first value to first column, 2nd to 2nd column .... 

# but when you are not sure about order of column, you have to specify column names also
INSERT INTO table_name
		(Id
		,Brand
		,Type
		,color
		,Price
		,Desc
		)
VALUES
		('14535974'
		,'Gucci'
		,'slippers'
		,'Pink'
		,695.00
		,NULL
		);
----------------------------------------------------------------------------------------------------------------------
# Temporary tables
----------------------------------------------------------------------------------------------------------------------
CREATE TEMPORARY TABLE temprary_table_name AS
	(
	SELECT *
	FROM original_table
	WHERE 'shoe_type' == 'sandals'
	)
# equal to: temprary_table_name = original_table[original_table['shoe_type'] == 'sandals']
----------------------------------------------------------------------------
# commenting
for 1 line: - -, eg:
SELECT column_1
- -,column_2
,column_3
,column_4
from table_name


for multiple lines:
/**/, eg:
SELECT column_1
/*,column_2
,column_3
*/
,column_4
from table_name
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Operators 																Operators
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
# WHERE clause operators
SELECT column_1, column_2
FROM table_name
WHERE column_n operator value;

eg:
SELECT column_1
,column_2
,column_3
FROM table_name
WHERE column_1 = 'blablabla';
----------------------------------------------------------------------------
# New clauses and Operators in SQL
WHERE
BETWEEN 	Between an inclusive range
IN
OR  		SQL processing AND before OR
AND 		SQL processing AND before OR
NOT
LIKE
ORDER BY
GROUP BY

#Example of BETWEEN
SELECT column_1
,column_2
,column_3
FROM table_name
WHERE column_3 BETWEEN 10 AND 20;

#Example of IN
SELECT column_1
,column_2
,column_3
FROM table_name
WHERE column_2 IN (9,10,11);
# srif wo rows jin k column_2 ki values (9,10,11) me sy koi 1 h

#Example of OR
SELECT column_1
,column_2
,column_3
FROM table_name
WHERE column_3 = 'amir' OR 'hamza';

#Example of NOT
SELECT *
FROM table_name
WHERE NOT column_1 = 'bla_1' AND NOT column_1='bla_2;

# IN vs. OR
IN works the same as OR.
Benefits of IN:
	1- long list of options
	2- IN executes faster than OR
	3- Don't have to think about the order with IN
	4- Can contain another SELECT

NOTE: if you're using OR and AND together be careful about order of operations and use parentheses
----------------------------------------------------------------------------
# Operator
=			Equal
<>			Not equal
> 		
< 		
>=
<=		
IS NULL 	 Is a null value


#Example of IS NULL
SELECT column_1
,column_2
,column_3
FROM table_name
WHERE column_3 IS NULL;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Wildcards 																Wildcards
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Wildcards:
	allow more precise search capabilities
	Special character used to match partsof a value
	Search pattern made from literal text, Wildcard character, or a combination
	uses LIKE as an operator(though technically a predicate)
	can only be  used with strings
	cannot be used for non-text datatypes
	Helpful for data scientist as they explore string variables
	not match NULLs
----------------------------------------------------------------------------
----------------- % -----------------
'%Pizza'   		= Grabs anything ending with the word Pizza
'Pizza%'   		= Grabs anything after the word Pizza
'%Pizza%'  		= Grabs anything before and after the word Pizza

'S%E' 	   		= Grabs anything that starts with "S" and ends with "E" (like sadie)
't%@gmail.com'	= Grabs gmail addresses that start with "t"

----------------- _ -----------------

WHERE column_n LIKE '_Pizza' # Note: not supported by DB2
# output:
	spizza
	mpizza
# equal to: column_n LIKE '%Pizza'

-----------------[]----------------

Bracket [] Wildcard:
	used to specify a set of characters in a specific location
	Does not work with all DBMS
	Does not work with SQLite
----------------------------------------------------------------------------
 Downsides of Wildcards:
 	Takes longer to run
 	Better to use another operator (if possible): =, <, =, AND etc.
 	Statements with Wildcards will take longer to run if used at the end of search patterns
 	Placement of Wildcards is important
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Sort data 																Sort Data
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
ORDER BY 
	allows user to sort data by particular columns
	Takes the name of one or more columns
	Add a comma after each additional column name
	Can sort by a column not retrieved
	Must always be the last clause in a select statement
----------------------------------------------------------------------------
ORDER BY 2,3	# 2 means 2nd columnn and 3 means 3rd column, etc
----------------------------------------------------------------------------
Sort Direction

DESC = descending order
ASC  = ascending order

Only applies to the  column names it directly precedes
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
								Math operations 													Math operations
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Multiplication Example:
SELECT
column_1
,column_2
,column_3 * column_4 AS calculated_column
FROM table_name

# it returns 3 columns: column_1, column_2, calculated_column
----------------------------------------------------------------------------
Order of Operations:
parentheses
Exponents
Multiplication
Division
Addition
Subtraction
"Please excuse my dear Anty Sally"
----------------------------------------------------------------------------
Combining Math Operations
SELECT column_1
,column_2
,column_3
,(column2-column_5)/column_3 AS calculated_column
FROM table;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
									Aggregate 														Aggregate
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Aggregate
	used to summamrize data
	Finding the highest and lowest values
	Finding the total number of rows
	Finding the average value
	etc..
----------------------------------------------------------------------------
Aggregate functions:
AVG()		# ignoring NULL values
COUNT()
MIN() 		# ignoring NULL values
MAX()		# ignoring NULL values
SUM()
----------------------------------------------------------------------------
AVG:
	SELECT AVG(column_5) AS avg_column_5
	FROM table_name

note: AVG() ignore rows containing NULL values
----------------------------------------------------------------------------
COUNT:
	SELECT COUNT (*) AS total_customers
	FROM table_name;
# COUNT(*) counts all the rows in a table containing values or NULL values

	SELECT COUNT(CustomerID) AS	total_customers
	FROM table_name
# Count(column) counts all the rows in a specific column ignoring NULL values
----------------------------------------------------------------------------
MAX:
	SELECT MAX(column_name) AS max_column_price
	FROM table_name
----------------------------------------------------------------------------
MAX and MIN:
	SELECT MAX(column_1) AS max_column_price
	,MIN(column_1) AS min_column_price
	FROM table_name
----------------------------------------------------------------------------
MIN:
	same as MAX
----------------------------------------------------------------------------
SUM:
	same as MAX, MIN
----------------------------------------------------------------------------
SUM (with condition):
	SELECT SUM(column_1*column_2) AS total_of_2columns
	FROM table_name
	WHERE column_n = 24;
----------------------------------------------------------------------------
DISTINCT

Using DISTINCT on Aggregate Functions
	<skiping duplicated in specific column> amir
	if DISTINCT is not specified, ALL is assumed
	Cannot use DISTINCT on COUNT(*)
	No value to use with MIN and MAX functions
SELECT COUNT(DISTINCT column_n)
FROM table_name
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
									Grouping Data 													Grouping Data
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------

GROUP BY
	can contain multiple columns
	Every column in your SELECT statement must be present in a GROUP BY clause, except for aggregated  calculations
	NULLs will be grouped together if your GROUP BY column contains NULLs
	WHERE does not work for groups because WHERE filters on rows, instead use HAVING clause to filter for groups

SELECT
Region
,COUNT(CustomerID) AS total_customers
FROM table_name
GROUP by Region;

HAVING Example:

	SELECT
	CustomerID
	,COUNT (*) AS orders
	FROM table_name
	GROUP BY CustomerID
	HAVING COUNT (*) >= 2
----------------------------------------------------------------------------
WHERE vs. HAVING
WHERE filters before data is grouped
HAVING filters after data is grouped
Rows eliminated by the WHERE vlause will not be a included in the group
----------------------------------------------------------------------------
ORDER BY with GROUP BY

ORDER BY 
	sorts data
	its a last thing that we put in our query

GROUP BY does not sort data

SELECT column_1
,column_2
FROM table_name
GROUP BY column_1
ORDER BY column_2 DESC;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
						Subqueries and Joins 													Subqueries and Joins
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Subqueries
	Queries embedded into other queries
	Relational Databases store data in multiple tables
	Subqueries merge data from multiple sources together
	Helps with adding other filtering criteria
	There is no limit to the number of subqueries you can have
	Performance slows when you nest too deeply
	Subquery selects can only retrieve a single column
	Not always the best option due to Performance
 	just one of many teqniques we can use to combine information together from multiple tables

2 tables me sy alag alag data nikal kar 1 sath jorna


Note: It is a really important when you working with subqueries is make sure indenting things, this is help you a lot

SELECT CustomerID
,CompanyName
,Region
FROM Customers_table
WHERE CustomerID in (SELECT
customerID
FROM orders_table
Where column_4 > 100);

Always Perform the innermost SELECT portion first
if i am looking somebody's query and try to trebelshot it i always start with innermost queriy to see what's going on
----------------------------------------------------------------------------
 Subquery in Subquery

 SELECT Customer_name, Customer_contact
 FROM cust_table IN
 	SELECT customer_id
 	FROM orders_table
 	WHERE order_number IN ( SELECT order_number
 								FROM OrderItems_table
 								WHERE product_name = 'Toothbrush');
----------------------------------------------------------------------------
Subqueries for Calculations

# task: Total number of orders placed by every customer

SELECT COUNT(*) AS orders
FROM Orders
WHERE customer_id = '143569';

SELECT customer_name
	,customer_state(SELECT COUNT(*) AS orders FROM Orders WHERE Orders.customer_id = Customer.customer_id) AS orders
FROM customers
ORDER BY customer_name
----------------------------------------------------------------------------
						JOINS
----------------------------------------------------------------------------
Benefits of Breaking Data into Tables
	Efficient storage
	Easier manipulation
	Greater scalability
	Logically models a process
	Tables are related through common valuse(keys)

----------------------------------------------------------------------------
JOINS:
	Associate correct records from each table on the fly
	Allows data retrieval from multiple tables in one query
	Joins are not physical - they persist for the duratino the query execution
	The more tables you join, the slower the database will perform
----------------------------------------------------------------------------
JOINS types:
	Cartesian (cross) Joins
	Inner Joins
	Left
	Right
	FULL Outer
----------------------------------------------------------------------------
Cartesian (cross) Joins:
	Each row from the first table joins with all the rows of another table, if we have 10 rows in table_1 and 10 rows in table_2 and we apply Cartesion/Cross join we obtain 100 records
	Very computationally taxing so Not frequently used 
	Wille return products with the incorrect vendor or no vendor at all

SELECT product_name
,unit_price
,company_name
FROM suppliers CROSS JOIN table_name;
# the ouput will be the number of joins in the 1st table multiplied by the number of rows in the 2nd table
----------------------------------------------------------------------------
Inner Joins:
	most frequantly used JOINS in SQL
	select records that have matching values in both tables
	no limit what you can join, 
SELECT suppliers.CompanyName
,ProductName
,UnitPrice
FROM suppliers INNER JOIN Products ON suppliers.supplierid = Products.supplierid


# Inner join with Multiple Tables
SELECT o.OrderID, c.CompanyName, e.LastName
FROM((Orders 0 INNER JOIN Customers c ON o.CustomerID = c.CustomerID)
INNER JOIN Employees e ON o.EmployeeID = e.EmployeeID);
----------------------------------------------------------------------------
Best Practices With Joins
	make sure you're pre-qualifying names
	Do not make unnecessary joins
	Think about the type of join you are making
	How are you connecting records?
----------------------------------------------------------------------------
				Aliases and Self Joins
----------------------------------------------------------------------------
SELECT vendor_name
,product_name
,product_price
FROM Vendors_table as v, Products_table as p 
WHERE v.vendor_id = p.vendor_id;



# Self Joins
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID = B.CustomerID 
AND A.City = B.City
ORDER BY A.City;  

specially when you are joining the table to it self (self joins) you have to have a table Aliase, there is no other way  this could happen
----------------------------------------------------------------------------
Left, Right, and Full Outer Joins
----------------------------------------------------------------------------
note: SQLite only does Left Joins
Other DBMS use all joins
----------------------------------------------------------------------------
Left Join

SELECT C.CustomerName, o.orderID
FROM Customers C
LEFT JOIN Orders O ON C.CustomerID = O.CustomerID
ORDER BY C.CustomerName;
----------------------------------------------------------------------------
Right Join
note: not supported by SQLite

SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FRom Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;
----------------------------------------------------------------------------
Full Outer Join 
note: not supported by SQLite

SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;
----------------------------------------------------------------------------
										UNIONS
----------------------------------------------------------------------------
UNIONS

The UNION operator is used to combine the result-set of two or more SELECT statements.
Each SELECT statement within UNION must have the same numeber of columns
Columns must have similar data types
The column in each SELECT statement must be in the same order

# Basic Union Setup
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;

# Which German cities have suppliers
SELECT City, Country FROM Customers
WHERE Country='Germany'
UNION
SELECT City, Country FROM Suppliers
WHERE Country='Germany'
ORDER BY City;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
						Modifying the data 													Modifying the data
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
String:

String Functions:
	Concatenate
	Substring
	Trim
		RTRIM
		LTRIM
		TRIM
	Upper
	Lower
----------------------------------------------------------------------------
Concatenate:

SELECT CompanyName
, ContactName
, CompanyName || ' (' || ContactName || ')'
FROM customers_table

Note: SQL server support <+> instead of <||>
#in pandas: 
	df['new_column'] = df.CompanyName + '(' + df.ContactName + ')'
----------------------------------------------------------------------------
TRIM:

SELECT TRIM("	You the best.	") AS TrimmdeString;
----------------------------------------------------------------------------
Substring:

Returns the specified number of characters from a particular position of a givin string

SUBSTR(string name
	, string position
	, number of characters to be returned);

SELECT first_name
, SUBSTR (first_name, 2, 3)
FROM Employees_table
WHERE department_id = 60;
# in pandas:
	df['new'] = df.CompanyName.str[2:2+3] # ignoring the condition <WHERE departmend_id = 60>
----------------------------------------------------------------------------
Upper:
	SELECT UPPER(column_name) FROM table_name;
----------------------------------------------------------------------------
LOWER:
	SELECT LOWER(column_name) FROM table_name;
----------------------------------------------------------------------------
UCASE:
	SELECT LOWER(column_name) FROM table_name;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
						Date and Time 														Date and Time
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Date:
	"As long as your data contains only the date portion, your queries wilkl work as expected. However, if a time portion is involved, it gets more complicated"
	"The most difficult part when working with dates is to be sure  that the format of the date you are trying to insert, maatches the format of the date column in the database."
	"Dates are stored as datetypes"
	"Each DBMS uses it's own variety of datatypes"

Wednesday, September 17th, 2008
9/17/2008 5:14:56 P.M. EST
9/17/2008 19:14:56 P.M. GMT
2612008 (Julian format)

DATE
Format: YYYY-MM-DD

DATETIME
Format: YYYY-MM-DD HH:MI:SS

TIMESTAMP
Format: YYYY-MM-DD HH:MI:SS

if you Query a DATETIME with: 
	WHERE PuchaseDatee = '2016-12-12'
You will get no results, because there is also HOURS, MINITS, and SECONDS that should be inclued in your query
----------------------------------------------------------------------------
SQLite support 5 date and time functions:
	DATE(timestring, modifier, modifier, ...)
	TIME(timestring, modifier, modifier, ...)
	DATETIME(timestring, modifier, modifier, ...)
	JULIANDAY(timestring, modifier, modifier, ...)
	STRFTIME(format, timestring, modifier, modifier, ...)
----------------------------------------------------------------------------
Timestrings:
	
A time string are what you want to extract from the Datetime function.
we have a lot of diffirent Timestrings that we can use:

YYYY-MM-DD
YYYY-MM-DD HH:MM
YYYY-MM-DD HH:MM:SS
YYYY-MM-DD HH:MM:SS.SSS
YYYY-MM-DDTHH:MM
YYYY-MM-DDTHH:MM:SS
YYYY-MM-DDTHH:MM:SS.SSS
HH:MM
HH:MM:SS
HH:MM:SS.SSS
----------------------------------------------------------------------------
Modifiers:
	NNN days------------start of year
	NNN hours-----------start of day
	NNN minutes---------weekday N
	NNN.NNNN seconds----unixepoch
	NNN months----------localtime
	NNN years-----------utc
	start of month 		

a timestring can be followed by 0 modifiers or multiple modifires, each modifier transforms that is apply to the time value is applied from left to right, the order is very important when you apply a modifieres. 
----------------------------------------------------------------------------
SELECT Birthdate_column
,STRFTIME('%Y', Birthdate_column) AS Year
,STRFTIME('%m', Birthdate_column) AS Month
,STRFTIME('%d', Birthdate_column) AS Day
FROM employees_table
# return 3 new columns <Year> containing year of birth, <Month> containing month of birth, and <Day> containing day of birth
----------------------------------------------------------------------------
Current Date:
	SELECT DATE('now');
----------------------------------------------------------------------------
Year, Month and Day for the current Date:
	SELECT STRFTIME('%Y %m %d', 'now'); 
----------------------------------------------------------------------------
Hour, Minute, Seconds and Milliseconds from Current DATETIME:
	SELECT STRFTIME('%H %M %S %s', 'now');
----------------------------------------------------------------------------
# Compute Age using Birthdate
SELECT Birthdate
,STRFTIME('%Y', Birthdate) AS Year
,STRFTIME('%m', Birthdate) AS Month
,STRFTIME('%d', Birthdate) AS Day
,DATE(('now') - Birthdate) AS Age
FROM employees_table
# return 5 columns, Birthdate, Year, Month, Day, Age
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
						Case Statements 														Case Statements
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Case Statements:
	Mimics if-then-else Statements found in most programing languages
	Can be used in SELECT, INSERT, update and DELETE statements

CASE 
WHEN C1 THEN E1
WHEN C2 THEN E2
....
ELSE [result else]
END


CASE input_	expression 
	WHEN when_expression THEN result_expression [...n]
	[ELSE else_result_expression]
END


SELECT
EmployeeID
,first_name
,LastName
,city
,CASE city
	WHEN 'calgary' THEN 'calgary' ELSE 'Other' END calgary # END k bad new column ka nime define kya h
	FROM Employees_table
	ORDER BY LastName, first_name;

# 1 naya column <calgary> banao, jab <city> me 'calgary' ho to new column me bhi 'calgary' dal do, warna 'Other' daal do
----------------------------------------------------------------------------
SELECT 
trackID
,name
,bytes
,CASE
WHEN bytes < 30000 THEN 'small'
WHEN bytes >= 30000 AND bytes <= 50000 THEN 'mediam'
WHEN bytes >= 50001 THEN 'large'
ELSE 'Other'
END bytescategory
FROM Tracks_table;
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
						Views 																					Views
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Views:
	Can add or remove columns without changing Schema
	Use it to encapsulate queries
	The view will be removed after database connection has ended

we are always combining data from multiple sources or transforming it in some way. As you know,  sometimes things like the order of operations can get a little ricky. Instead of creating a whole new table, sometimes we can create the illusion of a table by using a view.
A view is essentially a stored query, and it helps us clean up our queries and simplify when we have to write.
In a view, you can add or remove columns without changing the schema.  You're not actually writing the query to the database or  anything, what you're doing is you're kind of storing it for the time being. This is really helpful and pays off when we use it to encapsulate queries
The beauty of the view is that it can be used like a table. But it's unlike a table in that you don't have to have ETL or run ETL on any of the data. This helps a lot by encapsulating complex queries or complex calculations that you're trying to write.
It can really help simplify it.
It can also be used in pretty much any database, except for stored procedures.
Views are really most helpful if you need to join a set of tables and  you're having trouble getting calculations.  Particularly those complex ones dealing with the order of operations in the right  order to get the output you're looking for.
Another benefit of views includes different securities or  write capabilities.  We talked about not being able to write data to an environment or to a particular database.
Views are helpful because you're creating a view of a table but not actually writing data to that table.  This is a way to get around some of those database writing limitations.
Another thing that views are helpful for is to create a stepping stone in multilevel queries.  For example, let's say you create a query that counts the number of cells that each person has made. You could then write a query that groups the salespeople into a particular group. Then you can count the sales of that group as well.
It just creates this multilevel dimension that you wouldn't have been able to do elsewhere.
And then, it also helps so that you're not transferring any data through and ETL process.
Views are definitely something that will come in handy, if you're in a particularly sticky situation or having some trouble with your calculation. It can definitely make things a lot easier for you.


CREATE [TEMP] VIEW [IF NOT EXISTS] view_name(column-name-list) AS select-statement;


CREATE VIEW my_view
AS
SELECT
rregiondescription
,t.territorydescription
,e.Lastname
,e.Fistname
,e.Hiredate
,e.Reportsto
FROM Region r
INNER JOIN Territiories t on r.regionid = t.regionid
INNER JOIN Employeeterritories et on t.TerritoryID = et.TerritoryID
INNER JOIN Employees e on et.employeeid = e.EmployeeID

# my view name is my_view, if i need to see my view:
	SELECT *
	FROM my_view;

# not need your view?
DROP VIEW my_view;

# Get a count of how many territories each employee has
SELECT count(territorydescription)
,Lastname
,Firstname
FROM my_view
GROP BY Lastname, Firstname;
----------------------------------------------------------------------------
Working Through a Problem from Beginning to End
	1- Data Understanding
		1- Most Importtant step
		2- Understanding relationships in your data
		3- NULL values
		4- String Values
		5- Dates and times
	2- Subject Area and  Businuess Understanding
		1- Until you gain businuess understanding, writing queries may take more time
		2- Understanding where data joins are
		3- Differentiating integers from strings
		4- Investing time to understand your subject will help later during data analysis
	3- Profilling
		1- Get into the details of your data
		2- Create a data model and map the fields and tables you need
		3- Consider joins and calculations
		4- Understand any data quality or format issues
	4- Start with SELECT
		1- Start simple
		2- Any query begins with SELECT statement
		3- Add in special formatting
		4- if using subqueries, start with the inner-most query and work outward
	5- Test and Troubleshoot
		1- do not wait until the end to test queries
		2- Test after each join or filter
		3- Are you getting the results you expect?
		4- Start small and go step by step when troubleshooting a query.
	6- Format & Comment
		1- Use correct formatting and identation
		2- Comment strategically
		3- Clean code and comments help when you revisit or hand off code
	7- Review
		1- always revies old queries
		2- Business rules
		3- Date changes
		4- Date indicators
		5- Work the problem for beginning to end
----------------------------------------------------------------------------